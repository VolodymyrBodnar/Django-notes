
У Django існує кілька стратегій кешування, які можна використовувати для підвищення продуктивності веб-застосунків. Ось основні з них:

1. **Кешування на рівні View (View-Level Caching)**:
   - Можна кешувати цілі відповіді від окремих відображень.
   - Це робиться за допомогою декораторів, таких як `@cache_page`.

2. **Кешування шаблонів (Template Fragment Caching)**:
   - Дозволяє кешувати певні частини шаблону, а не цілу сторінку.
   - Реалізується через тег `{% cache %}` у шаблонах Django.

3. **Кешування на рівні бази даних (Database Caching)**:
   - Кешування результатів запитів до бази даних.
   - Можна використовувати `django.core.cache.backends.db.DatabaseCache` як backend.

4. **Кешування на рівні файлової системи (File-based Caching)**:
   - Зберігає кеш-дані у файлах у файловій системі.
   - Конфігурується через `django.core.cache.backends.filebased.FileBasedCache`.

5. **Кешування в пам'яті (In-Memory Caching)**:
   - Найшвидший варіант, оскільки дані зберігаються в оперативній пам'яті.
   - Використовує `django.core.cache.backends.memcached.MemcachedCache` або `django.core.cache.backends.locmem.LocMemCache`.

6. **Кешування на рівні middleware (Middleware Caching)**:
   - Кешує всю відповідь для конкретних URL.
   - Конфігурується через `UpdateCacheMiddleware` та `FetchFromCacheMiddleware`.

Кожна з цих стратегій має свої плюси та мінуси, тому вибір залежить від конкретних потреб застосунку. Важливо звернути увагу на правильне управління часом життя кешованих даних, щоб уникнути застарілих даних і забезпечити актуальність інформації.


# Приклад кешування в памяті
Щоб реалізувати кешування запитів до бази даних у Django з використанням кешування в пам'яті, ви можете дотримуватися такого плану:

1. **Налаштування кешу**:
   - У файлі `settings.py` вашого Django проекту налаштуйте кеш. Для кешування в пам'яті можна використовувати `LocMemCache`:
     ```python
		CACHES = {
		    'default': {
		        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
		        'LOCATION': '127.0.0.1:11211',
		    }
		}
     ```

2. **Кешування запитів до бази даних**:
   - Використовуйте Django кеш API для зберігання та отримання результатів запитів.
   - Приклад кешування запиту:
     ```python
     from django.core.cache import cache

     def get_some_data():
         # Ключ для кешу
         cache_key = 'some_data'
         # Спробуйте отримати дані з кешу
         data = cache.get(cache_key)
         if not data:
             # Дані не знайдені в кеші, тому виконуємо запит до БД
             data = SomeModel.objects.all()
             # Збережіть результат в кеші
             cache.set(cache_key, data, timeout=300) # Зберігати дані протягом 300 секунд
         return data
     ```

У цьому прикладі, спочатку перевіряється, чи знаходяться дані в кеші. Якщо ні, то виконується запит до бази даних, а результати запиту кешуються. Це зменшує кількість запитів до бази даних, що може значно підвищити продуктивність для часто використовуваних запитів. Важливо також вибрати відповідний час життя кешу (`timeout`), щоб дані не застаріли.

# приклад з використанням Redis
Щоб використовувати Redis для кешування запитів до бази даних у Django, слідуйте цим крокам:

1. **Встановіть Redis**:
   - Встановіть Redis на ваш сервер. Якщо ви використовуєте Linux, це можна зробити за допомогою менеджера пакетів, наприклад, `sudo apt-get install redis-server`.
   - https://redis.io/docs/install/install-redis/

2. **Встановіть Python Redis бібліотеку**:
   - Використовуйте `pip` для встановлення пакету `redis`, наприклад: `pip install redis`.

3. **Налаштуйте Redis як кеш-бекенд у Django**:
   - В файлі `settings.py` додайте або оновіть налаштування кешу:
     ```python
     CACHES = {
         'default': {
             'BACKEND': 'django_redis.cache.RedisCache',
             'LOCATION': 'redis://127.0.0.1:6379/1',
             'OPTIONS': {
                 'CLIENT_CLASS': 'django_redis.client.DefaultClient',
             }
         }
     }
     ```
   - `LOCATION` має вказувати на ваш Redis сервер.

4. **Кешування запитів до бази даних**:
   - Приклад функції, яка використовує Redis для кешування:
     ```python
     from django.core.cache import cache

     def get_cached_data():
         cache_key = 'some_unique_key'
         data = cache.get(cache_key)
         if data is None:
             # Якщо дані не у кеші, отримуємо їх з бази даних
             data = SomeModel.objects.all()
             # Зберігаємо дані в Redis кеші
             cache.set(cache_key, data, timeout=3600)  # Зберігати дані протягом 1 години
         return data
     ```

У цьому прикладі, спочатку перевіряється, чи знаходяться дані в кеші Redis. Якщо дані відсутні, запит виконується до бази даних, а результати зберігаються у Redis. Це дозволяє зменшити навантаження на базу даних і прискорити відповідь застосунку, особливо при великому обсязі запитів або складних запитах до бази даних.

# Інвалідація (очишення) кешу


**Інвалідація кешу** - це процес видалення або оновлення даних у кеші, коли ці дані змінюються або більше не є актуальними. Це важливо, оскільки кешування може зберігати застарілі дані, що призводить до невідповідностей між кешем і поточним станом даних у базі даних. Інвалідація забезпечує, що користувачі отримують найактуальнішу інформацію.

Щоб інвалідувати кеш у Django, ось основні способи:

1. **Видалення конкретних ключів**:
   - Якщо ви знаєте, що певні дані змінилися, ви можете видалити відповідні ключі з кешу. Наприклад:
     ```python
     from django.core.cache import cache
     cache.delete('some_unique_key')
     ```

2. **Очищення всього кешу**:
   - Якщо вам потрібно повністю очистити кеш, використовуйте:
     ```python
     from django.core.cache import cache
     cache.clear()
     ```

**Приклад інвалідації кешу при зміні даних**:
Уявімо, що у нас є модель `Article`, і ми кешуємо список статей. Якщо стаття оновлюється або видаляється, нам потрібно інвалідувати кеш:

```python
from django.core.cache import cache
from .models import Article

def invalidate_article_cache():
    cache.delete('all_articles_key')

def update_article(article_id, new_data):
    article = Article.objects.get(id=article_id)
    for key, value in new_data.items():
        setattr(article, key, value)
    article.save()
    invalidate_article_cache()  # Інвалідуємо кеш після оновлення статті
```

У цьому прикладі, коли стаття оновлюється, кеш зі списком статей інвалідується, що забезпечує актуальність даних, які отримують користувачі.